# Copyright 2025 Cocotec Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Formatting support for Coco packages."""

load(
    "//coco/private:coco.bzl",
    "COCO_TOOLCHAIN_TYPE",
    "CocoPackageInfo",
    "LICENSE_ATTRIBUTES",
    "_coco_runfiles",
    "_create_coco_wrapper_script",
)

def _coco_fmt_test_impl(ctx):
    """Implementation for coco_fmt_test rule.

    Creates a test that runs 'popili format --verify' to check if Coco code
    is properly formatted. The test passes if code is formatted correctly,
    and fails if formatting changes are needed.
    """
    arguments = [
        "format",
        "--verify",
    ]

    wrapper_script = _create_coco_wrapper_script(ctx, ctx.attr.package, arguments)

    return DefaultInfo(
        executable = wrapper_script,
        runfiles = ctx.runfiles(transitive_files = _coco_runfiles(ctx, ctx.attr.package, True)),
    )

_coco_fmt_test = rule(
    implementation = _coco_fmt_test_impl,
    attrs = dict(LICENSE_ATTRIBUTES.items() + {
        "is_windows": attr.bool(mandatory = True),
        "package": attr.label(
            providers = [CocoPackageInfo],
            mandatory = True,
            doc = "The coco_package target to check formatting for",
        ),
    }.items()),
    doc = """Test rule that verifies Coco code formatting.

This rule creates a test target that runs `popili format --verify` on the
specified coco_package. The test passes if all Coco source files are properly
formatted according to the formatting settings in the package's Coco.toml file.

Example:
    ```python
    coco_package(
        name = "my_pkg",
        package = "Coco.toml",
        srcs = glob(["src/**/*.coco"]),
    )

    coco_fmt_test(
        name = "my_pkg_fmt_test",
        package = ":my_pkg",
    )
    ```

To skip this test for specific targets, use standard Bazel tags:
    ```python
    coco_fmt_test(
        name = "generated_fmt_test",
        package = ":generated_pkg",
        tags = ["manual"],  # Only run when explicitly requested
    )
    ```
""",
    test = True,
    toolchains = [
        COCO_TOOLCHAIN_TYPE,
    ],
)

def _coco_fmt_binary_impl(ctx):
    """Implementation for coco_fmt_binary rule.

    Creates an executable that runs 'popili format' to format Coco code.
    """
    arguments = [
        "format",
    ]

    wrapper_script = _create_coco_wrapper_script(ctx, ctx.attr.package, arguments)

    return DefaultInfo(
        executable = wrapper_script,
        runfiles = ctx.runfiles(transitive_files = _coco_runfiles(ctx, ctx.attr.package, True)),
    )

_coco_fmt_binary = rule(
    implementation = _coco_fmt_binary_impl,
    attrs = dict(LICENSE_ATTRIBUTES.items() + {
        "is_windows": attr.bool(mandatory = True),
        "package": attr.label(
            providers = [CocoPackageInfo],
            mandatory = True,
            doc = "The coco_package target to format",
        ),
    }.items()),
    doc = """Binary rule that formats Coco code.

This rule creates an executable target that runs `popili format` on the
specified coco_package, automatically formatting all Coco source files
according to the formatting settings in the package's Coco.toml file.

This target is typically auto-generated by coco_fmt_test and should not
be used directly.
""",
    executable = True,
    toolchains = [
        COCO_TOOLCHAIN_TYPE,
    ],
)

def coco_fmt_test(name, package, **kwargs):
    """Creates both a format test and a format binary.

    This macro creates two targets:
    1. A test target (with the given name) that checks formatting
    2. A binary target (name with _test suffix removed) that formats code

    Args:
        name: The name of the test target. Should typically end with '_test'.
        package: The coco_package target to check/format.
        **kwargs: Additional arguments forwarded to both rules (e.g., tags, visibility).

    Example:
        ```python
        coco_package(
            name = "my_pkg",
            package = "Coco.toml",
            srcs = glob(["src/**/*.coco"]),
        )

        coco_fmt_test(
            name = "my_pkg_fmt_test",
            package = ":my_pkg",
        )

        # This creates two targets:
        # - my_pkg_fmt_test: Test that fails if code isn't formatted
        # - my_pkg_fmt: Binary to format the code
        #
        # Usage:
        # bazel test //:my_pkg_fmt_test  # Check formatting
        # bazel run //:my_pkg_fmt        # Format code
        ```
    """
    is_windows_select = select({
        "@platforms//os:windows": True,
        "//conditions:default": False,
    })

    # Create the test target
    _coco_fmt_test(
        name = name,
        package = package,
        is_windows = is_windows_select,
        **kwargs
    )

    # Create the formatter binary target
    # If name ends with _test, create a binary without that suffix
    binary_name = name[:-5] if name.endswith("_test") else name + "_format"

    # Filter out test-only attributes for the binary target
    binary_kwargs = {k: v for k, v in kwargs.items() if k != "size" and k != "timeout"}

    _coco_fmt_binary(
        name = binary_name,
        package = package,
        is_windows = is_windows_select,
        **binary_kwargs
    )
